#!/usr/bin/perl

#######################################################################################
# Parser script to parse the output generated by multiIntersectBed
# Author	: 	Gyan Prakash Mishra
# Email id 	: 	j12mishra[at]gmail.com
# Afiliation:	:	Institute of Life Sciences, Bhubaneswar
# 			Autonomous institute of Department of Biotechnology, Govt. of India.
# Version 	: 	Version 1.0
#######################################################################################

use strict;
use warnings;
use Statistics::Basic qw(:all);
use File::Basename;

my @ext_bed = ();
my @gtrd_bed = ();
my $i ;
for ($i=0;$i<@ARGV;$i++) 
{
		if($ARGV[$i] eq '--ext') 
		{
                	#print STDERR "\tUser's uploaded bed file:";
                	my $bail = 0; #print "$i\n";
                	while ($ARGV[++$i] !~ "--gtrd" || $ARGV[++$i] !~ /[0-9]/ ) 
			{
                	        
				push(@ext_bed, $ARGV[$i]);
                	        #print STDERR "\t$ARGV[$i]\n";
                	        if ($i>=@ARGV-2) {
                	               $bail = 1;
                	               last;
                        	}
                	}
                	last if ($bail == 1);
                	$i--;
		}
		if($ARGV[$i] eq '--gtrd') {
                #print STDERR "\n\tGTRD selected bed file: ";
                my $bail = 0;
                while (++$i < @ARGV) {
                        push(@gtrd_bed , $ARGV[$i]);
                        #print STDERR "\t$ARGV[$i]\n";
                        if ($i>=@ARGV-2) {
                                $bail = 1;
                                last;
                        }
                }
                	last if ($bail == 1);
			$i--;
		}
		
}
my $len_ext = scalar(@ext_bed);
my $len_gtrd = scalar(@gtrd_bed);
#print "$len_ext\n";
#print "$len_gtrd\n";




my @bed = @ARGV;
my $dir =shift(@bed);
#my $path = "";
my $path2 = $dir . "/";
#my $session = basename($path);
my $bp_overlap = pop @bed;
#print "$bp_overlap\n";
#my $shuff = pop @bed;
#my $genome = pop @bed ;
my @filename;
my @bedfile;
my @count;
my $label;

if( $len_ext >0){
	foreach my $l1 (@ext_bed)
	{
		chomp($l1);
		my $path1 = $path2 . $l1 ;
		`sortBed -i $path1 >$path1.".bed"`;
		`mv $path1.".bed" $path1`;
		push @bedfile,$path1;
		my $basename= basename($l1);
		$basename=~s/.bed//;
		push @filename,"$basename";
		my $length= `cat $path1|wc -l`;	
		chomp($length);
		my $median = med($path1);
		print "$basename\t$length\t$median\n";
	}
}
my @gtrd_path;
if( $len_gtrd >0){
	foreach my $l2 (@gtrd_bed)
	{
		chomp($l2);
		push @bedfile,$l2;
		my $basename= basename($l2);
		push @gtrd_path, dirname($l2);
		$basename=~s/.bed//;
		my @tf =split "_",$basename;
    		$basename = $tf[0]."-".$tf[1];
		push @filename,"$basename";
		my $length= `cat $l2|wc -l`;	
		chomp($length);
		my $median = med($l2);
		print "$basename\t$length\t$median\n";
	}
}

#my $i;
my $j;
my %file_hash;
for ($i =0; $i<=$#filename;$i++)
{
	$j=$i+1;
	$file_hash{$j} = $filename[$i];
}
my $c;
my @temp;
my @overlap;
my @region;
my %hash1;
my @res;
my $line;
my @matrix;
my @matrix1;
my $id =1;
my $id1 =1;
my $ide;
my @id_matrix;
my @mat;
my $check=0;
my $index;
my $len_arg =scalar(@bed);

`multiIntersectBed -header -i @bedfile >$path2/multiintersect_out`;
`sed -i 's/.bed//g' $path2/multiintersect_out`;
my $replace =$path2;
$replace=~s/\//\\\//g;
`sed -i 's/$replace//g' $path2/multiintersect_out`;
my $len = $len_arg+5;
`cut -f 5-$len $path2/multiintersect_out >$path2/corr_matrix`;
for($i=0; $i < $#gtrd_path;$i++)
{
	my $path3 = $gtrd_path[$i] . "/";
	$path3=~s/\//\\\//g;
	`sed -i 's/$path3//g' $path2/corr_matrix`;
}
open (FH, "$path2/multiintersect_out") or die;
@overlap = (<FH>);
$c=0;
foreach $line (@overlap)
{
        chomp($line);

        if ($line !~ /chrom/){

                @region = split /\t/, $line;

                push (@{$hash1{$region[4]}{$region[0]}},$region[1],$region[2]);
        }
}
foreach my $key1 (sort keys %hash1) {
	#print "$key1-------\t";
	@mat = split(',', $key1);
	my $mat_len=@mat;	
#	print "@mat\n";
	my $ref1;
	my @hotspot;
	my $filebed;
	if($mat_len >=1)
	{	
		for($c=1;$c<=scalar(@mat);$c++)
        {
			$index=$c-1;
			$ref1 = $mat[$index];
			push @hotspot,$file_hash{$ref1};
		}
		$filebed=join('_',@hotspot);
		$filebed =~s/_$//;
		open (OUT,">$path2/$filebed.bed") or die;
	}
	else
	{	
		$filebed= $file_hash{$key1};
		chomp($filebed);
		open (OUT,">$path2/Unique_$filebed.bed") or die ;
	}
	$check=0;
	foreach my $key2 (sort keys %{$hash1{$key1}}){
		@res = @{$hash1{$key1}{$key2}};
		my $tmp = @res;
		#print "@res\t$tmp\n";
		for($j =0; $j <= $#res; $j=$j+2)
		{
			
			# filter based on no. of basepair overlap
			my $bp = $res[$j+1]-$res[$j];
			#print "$bp\n";
			if($bp > $bp_overlap)
			{
				$check++;
				print OUT "$key2\t$res[$j]\t$res[$j+1]\n";
        			$ide = $key2."-".$res[$j].":".$res[$j+1];
				push @id_matrix ,$ide;
				chomp($id);
				for($c=1;$c<=$mat_len;$c++)
				{
					$index = $c-1;
					#print "$c\t$mat_len\n";
					my $ref = $mat[$index];
					$matrix[$id][$ref]=1;
				}
			}
			$id++;
		}
	}
	for($j=1;$j<=$#mat;$j++)
	{
		$index = $j -1;
		$ide = $mat[$index];
		$matrix1[$id1][$ide]=$check;
	}
	$id1++;
	@hotspot=();
	my $mat_length =scalar @mat;
	for($c=0;$c<=scalar(@mat);$c++)
	{
		#$index=$c-1;
		$ref1 = $mat[$c];
		push @hotspot, $file_hash{$ref1};
	}
	my $hotspot_name;
	if($#hotspot > 1)
	{
		$hotspot_name =join(',',@hotspot);	
		$hotspot_name =~s/,$//;
	}
	else 
	{	
		$hotspot_name = $hotspot[0];	
	}
	#chomp(@est);
	print "$hotspot_name\t$filebed.bed\t$check\n";	
}


my @interval;
my $dist;
my $median;
sub med
{
        my @region = @_;
        open(FH1,"$region[0]") or die ;
        while(<FH1>)
        {
                chomp ($_);
                my @temp1 =split /\t/, $_;
                chomp($temp1[2],$temp1[1]);
                $dist = $temp1[2] - $temp1[1];
                push @interval,$dist;
        }
        my $median = median(@interval);
        return($median);

}




